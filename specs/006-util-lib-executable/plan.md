# Implementation Plan: Util CLI Architecture Alignment

**Branch**: `006-util-lib-executable` | **Date**: 2026-01-04 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/006-util-lib-executable/spec.md`

**Note**: This plan generated by `/speckit.plan` with 5 clarifying questions answered.

## Summary

Refactor the util CLI to align with industry-standard library + executable pattern while maintaining architectural differences for websites monorepo. Rename Utilities→UtilLib for consistency with util CLI name, migrate test targets (UtilitiesTests→UtilLibTests, UtilitiesCLITests→UtilIntegrationTests), implement pure black-box integration testing via TestHarness, and update all consumer targets atomically. ArgumentParser remains in util executable to keep UtilLib lightweight for programmatic consumers (21-dev, DesignSystem, IntegrationTests, DesignSystemTests).

**Key Architecture Decision**: Unlike subtree (where SubtreeLib is only used for testing), UtilLib is consumed programmatically by multiple targets that don't need CLI overhead. This requires ArgumentParser to stay in util executable rather than moving to the library.

## Technical Context

**Language/Version**: Swift 6.1+  
**Primary Dependencies**: swift-subprocess 0.2.1 (for CLI execution in integration tests), swift-argument-parser (util executable only), Subprocess + SwiftSoup (UtilLib)  
**Storage**: N/A (no persistent storage)  
**Testing**: swift-testing (Swift 6.1 built-in, macro-based framework)  
**Target Platform**: macOS 15+ (CLI tool, no multi-platform support required)
**Project Type**: Monorepo refactoring (no new features, architecture alignment only)  
**Performance Goals**: Test suite execution time must not regress (baseline: current test runtime)  
**Constraints**: 
- Zero breaking changes to CLI behavior (transparent refactor)
- All tests must pass at every commit (continuous validation)
- ArgumentParser stays in util executable (UtilLib must remain lightweight)
- TestHarness executes binary via path (no util executable dependency in tests)
**Scale/Scope**: 
- 4 consumer targets to update (21-dev, DesignSystem, IntegrationTests, DesignSystemTests)
- 2 test targets to rename/migrate (UtilitiesTests→UtilLibTests, UtilitiesCLITests→UtilIntegrationTests)
- 1 directory rename (Sources/Utilities/→Sources/UtilLib/)
- ~4-6 logical commits total

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Principle II: Spec-First & Test-Driven Development

**Status**: ✅ PASS

- ✅ Spec created before development (spec.md complete with 32 functional requirements)
- ✅ Single feature (architecture alignment only, no unrelated features)
- ✅ Independently testable (no dependencies on incomplete specs)
- ✅ Represents deployable increment (consistent naming + proper test architecture)
- ✅ User scenarios defined with acceptance criteria
- ✅ Focuses on behavior (refactoring, not implementation)
- ✅ Prioritized user stories (2×P1, 2×P2, 1×P3)
- ✅ TDD enforced: Tests must pass at every commit (clarification Q2)

### Principle IV: Design System Consistency

**Status**: ✅ PASS

- ✅ No DesignSystem changes required (refactoring targets only Utilities/util/tests)
- ✅ Consumer updates atomic (DesignSystem import updated with all other consumers)

### Principle V: Zero-Dependency Philosophy

**Status**: ✅ PASS

- ✅ No new dependencies added
- ✅ swift-subprocess already approved for build-time CLI testing
- ✅ Removes coupling (UtilIntegrationTests drops util executable dependency)

### Principle VII: Open Source Excellence

**Status**: ✅ PASS with Documentation Requirement

- ✅ Architecture decision documented (ArgumentParser placement rationale)
- ⚠️ **Required**: Architecture documentation must be written FIRST (clarification Q4 answer: Option A)
- ✅ KISS principle: Minimal refactor (rename + test architecture, no over-engineering)
- ✅ Clear code: Pattern proven by subtree project

**Gate Result**: ✅ PASS - No constitution violations. Documentation requirement captured in Phase 0.

## Project Structure

### Documentation (this feature)

```text
specs/006-util-lib-executable/
├── spec.md              # Feature specification (complete)
├── plan.md              # This file (/speckit.plan command output)
├── research.md          # Phase 0: TestHarness patterns, commit strategies, documentation structure
├── data-model.md        # Phase 1: Package.swift structure, TestHarness API
├── quickstart.md        # Phase 1: Validation commands
├── contracts/           # Phase 1: TestHarness contract
│   └── TestHarness.md
├── checklists/
│   └── requirements.md  # Specification quality validation (complete)
└── tasks.md             # Phase 2 (/speckit.tasks - not created by /speckit.plan)
```

### Source Code (repository root)

**Current Structure** (before refactor):
```text
Sources/
├── Utilities/               # Business logic library (TO BE RENAMED)
│   ├── Canonical/
│   ├── Headers/
│   ├── Sitemap/
│   ├── State/
│   └── Shared/
└── util/                    # CLI executable (unchanged)
    ├── Commands/
    └── Util.swift

Tests/
├── UtilitiesTests/          # Unit tests (TO BE RENAMED)
└── UtilitiesCLITests/       # Integration tests (TO BE RENAMED + REFACTORED)
```

**Target Structure** (after refactor):
```text
Sources/
├── UtilLib/                 # Renamed from Utilities (DIRECTORY RENAMED)
│   ├── Canonical/          # Business logic (unchanged)
│   ├── Headers/
│   ├── Sitemap/
│   ├── State/
│   └── Shared/
└── util/                    # CLI executable (unchanged)
    ├── Commands/
    └── Util.swift

Tests/
├── UtilLibTests/            # Renamed from UtilitiesTests (DIRECTORY RENAMED)
│   └── [existing test files]
└── UtilIntegrationTests/    # Renamed from UtilitiesCLITests (DIRECTORY RENAMED + NEW TESTHARNESS)
    ├── TestHarness.swift    # NEW: CLI execution utility (from subtree pattern)
    └── [existing test files migrated to use TestHarness]
```

**Package.swift Changes**:
```swift
// BEFORE
.target(name: "Utilities", dependencies: [Subprocess, SwiftSoup])
.executableTarget(name: "util", dependencies: [Utilities, ArgumentParser])
.testTarget(name: "UtilitiesTests", dependencies: ["Utilities"])
.testTarget(name: "UtilitiesCLITests", dependencies: ["Utilities", "util", "TestUtils", Subprocess])

// AFTER
.target(name: "UtilLib", dependencies: [Subprocess, SwiftSoup])  // RENAMED
.executableTarget(name: "util", dependencies: [UtilLib, ArgumentParser])  // Updated dependency
.testTarget(name: "UtilLibTests", dependencies: ["UtilLib"])  // RENAMED
.testTarget(name: "UtilIntegrationTests", dependencies: [Subprocess])  // RENAMED + REMOVED UtilLib/util/TestUtils
```

**Consumer Updates** (atomic with library rename):
```swift
// 21-dev, DesignSystem, IntegrationTests, DesignSystemTests
// BEFORE: import Utilities
// AFTER:  import UtilLib
```

**Structure Decision**: Monorepo refactoring with minimal file movement. Directory renames match target renames (SPM convention). TestHarness added inline in UtilIntegrationTests following subtree pattern. All changes maintain existing business logic - pure architecture alignment.

## Complexity Tracking

**Status**: N/A - No constitution violations requiring justification.

This refactor maintains simplicity:
- No new dependencies
- No new architectural layers
- Follows proven subtree pattern
- Minimal scope (renaming + test architecture only)

---

## Phase 0: Research & Documentation Architecture

**Objective**: Resolve unknowns and establish documentation structure before implementation.

### Research Tasks

1. **TestHarness Implementation Pattern**
   - Study subtree's TestHarness.swift (Tests/IntegrationTests/TestHarness.swift)
   - Extract reusable patterns: CommandResult struct, run() API, async/await usage
   - Identify macOS-specific adaptations (Foundation paths vs SystemPackage)
   - Document differences: subtree uses SystemPackage, util uses Foundation only
   
2. **Commit Strategy**
   - Define logical commit boundaries (clarification Q5: ~4-6 commits)
   - Plan test-passing checkpoints at each commit (clarification Q2: continuous validation)
   - Document rollback procedures if commit fails validation
   
3. **Documentation Structure** (clarification Q4: write first)
   - Architecture guide location: `.windsurf/rules/` or `docs/architecture/`?
   - Content: library+executable pattern, ArgumentParser placement rationale, when to use UtilLibTests vs UtilIntegrationTests
   - Format: Markdown, cross-referenced with spec.md clarifications

### Deliverable: research.md

Document findings for:
- TestHarness API contract (methods, types, error handling)
- Commit sequence with validation checkpoints
- Documentation structure and content outline
- Differences from subtree pattern (ArgumentParser placement, Foundation vs SystemPackage)

---

## Phase 1: Design & Contracts

**Prerequisites**: research.md complete, Constitution Check re-validated

### Design Artifacts

1. **data-model.md**
   - Package.swift target definitions (before/after)
   - TestHarness API structure (CommandResult, TestHarness struct)
   - Import graph changes (consumer dependencies)
   
2. **contracts/TestHarness.md**
   - TestHarness.run(arguments:) → CommandResult contract
   - CommandResult properties (stdout, stderr, exitCode, succeeded)
   - Error handling (subprocess failures, binary not found)
   - Path resolution (.build/debug/util location)

3. **quickstart.md**
   - Validation commands for each commit checkpoint
   - Test execution: `swift test --filter UtilLibTests`, `swift test --filter UtilIntegrationTests`
   - Build verification: `swift build`
   - Consumer validation: verify 21-dev, DesignSystem, IntegrationTests, DesignSystemTests compile

### Agent Context Update

Run `.specify/scripts/bash/update-agent-context.sh windsurf` to update `.windsurf/rules/` with:
- Architecture decision: ArgumentParser placement
- TestHarness pattern for future CLI tools
- Naming convention: CLI name → Lib suffix (util → UtilLib)

### Constitution Re-Check

Verify Phase 1 design artifacts satisfy:
- ✅ TDD: Tests defined before implementation in contracts/
- ✅ Documentation: Architecture guide drafted (Principle VII)
- ✅ Simplicity: No over-engineering in TestHarness design

---

## Phase 2: Task Breakdown

**Note**: Phase 2 completed by `/speckit.tasks` command (NOT this plan workflow).

**Expected Task Structure** (based on clarifications):

### Milestone 1: Documentation (1 commit)
- Write architecture documentation explaining pattern
- Document when to use UtilLibTests vs UtilIntegrationTests  
- Explain ArgumentParser placement rationale
- **Checkpoint**: Documentation review, all tests still passing

### Milestone 2: TestHarness Foundation (1 commit)
- Create Tests/UtilIntegrationTests/TestHarness.swift (adapted from subtree)
- Implement CommandResult struct
- Implement run(arguments:) method using swift-subprocess
- Write TestHarness validation tests (basic CLI execution, stdout/stderr capture)
- **Checkpoint**: TestHarness tests pass, existing tests unchanged

### Milestone 3: Library Rename + Consumer Updates (1 commit - ATOMIC)
- Rename Sources/Utilities/ → Sources/UtilLib/
- Update Package.swift: Utilities target → UtilLib target
- Update util executable dependency: Utilities → UtilLib
- Update all 4 consumers atomically: 21-dev, DesignSystem, IntegrationTests, DesignSystemTests
- Update Tests/UtilitiesTests/ → Tests/UtilLibTests/
- Update Package.swift: UtilitiesTests → UtilLibTests
- Update test imports: `import Utilities` → `import UtilLib`
- **Checkpoint**: All existing tests pass (unit + integration), swift build succeeds, all consumers compile

### Milestone 4: Integration Test Migration (1 commit)
- Rename Tests/UtilitiesCLITests/ → Tests/UtilIntegrationTests/
- Update Package.swift: UtilitiesCLITests → UtilIntegrationTests
- Remove UtilLib, util, TestUtils dependencies from UtilIntegrationTests
- Add only Subprocess dependency
- Migrate test files to use TestHarness instead of direct imports
- Update test imports: remove `import Utilities`, `import util`
- **Checkpoint**: All integration tests pass via TestHarness, zero coupling to UtilLib/util

### Milestone 5-6: CI Validation + Final Polish (1-2 commits)
- Verify all CI workflows pass
- Update any CI-specific references to old target names
- Final validation: all 32 functional requirements satisfied
- **Checkpoint**: CI green, feature complete per success criteria

**Commit Granularity**: 4-6 logical commits (clarification Q5: Option B)
**Test Policy**: Tests pass at every commit (clarification Q2: Option A)
**Implementation Order**: Dependency-based (clarification Q1: Option B) - documentation first, TestHarness before migration, library rename atomic with consumers

---

## Next Steps

1. **Immediate**: Run `/speckit.plan` Phase 0 research
   - Generate research.md with TestHarness patterns
   - Define commit sequence
   - Draft documentation outline

2. **After Phase 0**: Run `/speckit.plan` Phase 1 design
   - Generate data-model.md
   - Generate contracts/TestHarness.md
   - Generate quickstart.md
   - Update agent context

3. **After Phase 1**: Run `/speckit.tasks`
   - Generate detailed task breakdown (tasks.md)
   - Estimate time per task
   - Identify parallel opportunities

4. **Implementation**: Execute tasks following TDD
   - Write tests before implementation
   - Verify tests pass at each commit
   - Follow commit sequence from research.md

---

## Clarification Summary

All 5 planning questions answered (2026-01-04):

1. **Implementation order**: Dependency-based interleaving (Option B) - maximizes efficiency
2. **Testing strategy**: Tests pass at every commit (Option A) - enables bisect debugging
3. **TestHarness approach**: Implement and validate first (Option A) - cross-reference subtree
4. **Documentation timing**: Write documentation first (Option A) - guides implementation
5. **Commit granularity**: Logical units ~4-6 commits (Option B) - balanced reviewability

These decisions incorporated throughout this plan.
