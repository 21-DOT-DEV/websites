name: Deploy to Cloudflare Pages

on:
  workflow_call:
    inputs:
      artifact-name:
        description: 'Name of the build artifact to deploy'
        required: true
        type: string
      project-name:
        description: 'Cloudflare Pages project name'
        required: true
        type: string
      deploy-to-production:
        description: 'Deploy to production (true) or preview (false)'
        required: true
        type: boolean
      artifact-path:
        description: 'Path where artifact should be extracted'
        required: false
        type: string
        default: 'Websites'
    secrets:
      cloudflare-api-token:
        required: true
      cloudflare-account-id:
        required: true
      google-service-account-json:
        required: false
    outputs:
      deployment-url:
        description: 'The URL where the site was deployed'
        value: ${{ jobs.deploy.outputs.url }}

jobs:
  deploy:
    name: Deploy to Cloudflare Pages
    runs-on: ubuntu-latest
    env:
      DEPLOYMENT_BRANCH: preview
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    permissions:
      contents: read
      deployments: write
      pull-requests: write
    outputs:
      url: ${{ steps.cloudflare.outputs.url }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Determine deployment branch
        run: |
          if [[ ${{ inputs.deploy-to-production }} == true ]]; then
            echo "DEPLOYMENT_BRANCH=main" >> $GITHUB_ENV
            echo "üöÄ Deploying to PRODUCTION (main branch)"
          else
            echo "DEPLOYMENT_BRANCH=preview" >> $GITHUB_ENV
            echo "üîç Deploying to PREVIEW"
          fi
      
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.artifact-name }}
          path: ${{ inputs.artifact-path }}/${{ inputs.project-name }}
      
      - name: Extract artifact if zipped
        run: |
          deploy_dir="${{ inputs.artifact-path }}/${{ inputs.project-name }}"
          
          # Check if artifact is a zip file (docs workflow)
          if [ -f "${deploy_dir}/${{ inputs.project-name }}.zip" ]; then
            echo "üì¶ Extracting documentation archive..."
            unzip -q "${deploy_dir}/${{ inputs.project-name }}.zip" -d "${deploy_dir}"
            rm "${deploy_dir}/${{ inputs.project-name }}.zip"
            echo "‚úÖ Documentation extracted and ready for deployment"
          fi
      
      - name: Deploy to Cloudflare Pages
        id: cloudflare
        uses: cloudflare/pages-action@v1
        with:
          apiToken: ${{ secrets.cloudflare-api-token }}
          accountId: ${{ secrets.cloudflare-account-id }}
          projectName: ${{ inputs.project-name }}
          directory: ${{ inputs.artifact-path }}/${{ inputs.project-name }}
          branch: ${{ env.DEPLOYMENT_BRANCH }}
          wranglerVersion: '3'
      
      - name: Prepare deployment comment
        if: github.event_name == 'pull_request'
        id: format-output
        run: |
          if [ "${{ steps.cloudflare.outcome }}" == "failure" ]; then
            DEPLOYMENT_STATUS="‚ùå Deployment Failed!"
          else
            DEPLOYMENT_STATUS="‚úÖ Deployment Successful!"
          fi

          echo "DEPLOYMENT_TEXT<<EOF" >> $GITHUB_ENV
          echo "### Deploying Preview for ${{ inputs.project-name }} üöÄ" >> $GITHUB_ENV
          echo "---" >> $GITHUB_ENV
          echo "| **Name** | **Result** |" >> $GITHUB_ENV
          echo "|---------------------------------|------------------------|" >> $GITHUB_ENV
          echo "|üîÄ Latest Commit | ${{ github.sha }} |" >> $GITHUB_ENV
          echo "|üõ∞Ô∏è Status | $DEPLOYMENT_STATUS |" >> $GITHUB_ENV
          echo "|ü™µ Action Run | [View Logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) |" >> $GITHUB_ENV
          echo "|üîç Preview URL | [${{ steps.cloudflare.outputs.url }}](${{ steps.cloudflare.outputs.url }}) |" >> $GITHUB_ENV
          echo "|üïµüèª‚Äç‚ôÇÔ∏è Alias URL | [${{ steps.cloudflare.outputs.alias }}](${{ steps.cloudflare.outputs.alias }}) |" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
      
      - name: Comment deployment preview on PR
        if: github.event_name == 'pull_request'
        run: |
          # Try to edit last comment, fallback to creating new comment if none exists
          if ! gh issue comment ${{ github.event.pull_request.number }} --edit-last --body "${{ env.DEPLOYMENT_TEXT }}" 2>/dev/null; then
            echo "No previous comment found, creating new comment..."
            gh issue comment ${{ github.event.pull_request.number }} --body "${{ env.DEPLOYMENT_TEXT }}"
          fi
      
      - name: Deployment complete
        run: |
          echo "‚úÖ Deployment successful!"
          echo "üìç Deployment URL: ${{ steps.cloudflare.outputs.url }}"
          echo "üåø Branch: ${{ env.DEPLOYMENT_BRANCH }}"
      
      - name: Determine sitemap URL
        if: inputs.deploy-to-production == true
        id: sitemap
        run: |
          # Map project-name to production sitemap URL
          case "${{ inputs.project-name }}" in
            "21-dev")
              SITEMAP_URL="https://21.dev/sitemap.xml"
              ;;
            "docs-21-dev")
              SITEMAP_URL="https://docs.21.dev/sitemap.xml"
              ;;
            "md-21-dev")
              SITEMAP_URL="https://md.21.dev/sitemap.xml"
              ;;
            *)
              echo "::warning::Unknown project name: ${{ inputs.project-name }}, skipping sitemap submission"
              echo "skip=true" >> $GITHUB_OUTPUT
              exit 0
              ;;
          esac
          
          echo "sitemap-url=$SITEMAP_URL" >> $GITHUB_OUTPUT
          echo "skip=false" >> $GITHUB_OUTPUT
          echo "üìç Sitemap URL: $SITEMAP_URL"
      
      - name: Submit sitemap to Google Search Console
        if: inputs.deploy-to-production == true && steps.sitemap.outputs.skip != 'true'
        continue-on-error: true
        run: |
          set +e
          
          echo "üîç Submitting sitemap to Google Search Console..."
          echo "   Sitemap URL: ${{ steps.sitemap.outputs.sitemap-url }}"
          
          # Extract domain for sc-domain format (Domain property)
          DOMAIN=$(echo "${{ steps.sitemap.outputs.sitemap-url }}" | sed -E 's|https?://([^/]+).*|\1|')
          SITE_URL="sc-domain:${DOMAIN}"
          echo "   Site URL: $SITE_URL (Domain property)"
          
          # Write service account JSON to temporary file
          SA_KEY_FILE=$(mktemp)
          echo '${{ secrets.google-service-account-json }}' > "$SA_KEY_FILE"
          
          # Extract service account email
          SA_EMAIL=$(jq -r '.client_email' "$SA_KEY_FILE")
          
          # Create JWT for OAuth with correct scope (webmasters, not indexing)
          HEADER='{"alg":"RS256","typ":"JWT"}'
          PAYLOAD='{"iss":"'$SA_EMAIL'","scope":"https://www.googleapis.com/auth/webmasters","aud":"https://oauth2.googleapis.com/token","exp":'$(($(date +%s)+3600))',"iat":'$(date +%s)'}'
          
          # Base64url encode
          HEADER_B64=$(echo -n "$HEADER" | base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n')
          PAYLOAD_B64=$(echo -n "$PAYLOAD" | base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n')
          
          # Sign with private key
          SIGNATURE=$(echo -n "${HEADER_B64}.${PAYLOAD_B64}" | \
            openssl dgst -sha256 -sign <(jq -r '.private_key' "$SA_KEY_FILE") | \
            base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n')
          
          JWT="${HEADER_B64}.${PAYLOAD_B64}.${SIGNATURE}"
          
          # Get OAuth access token
          ACCESS_TOKEN=$(curl -s -X POST https://oauth2.googleapis.com/token \
            -H "Content-Type: application/json" \
            -d '{"grant_type":"urn:ietf:params:oauth:grant-type:jwt-bearer","assertion":"'$JWT'"}' | \
            jq -r '.access_token')
          
          # Clean up temporary file
          rm -f "$SA_KEY_FILE"
          
          if [ -z "$ACCESS_TOKEN" ] || [ "$ACCESS_TOKEN" = "null" ]; then
            echo "::warning::Failed to obtain Google OAuth token"
            exit 0
          fi
          
          # URL-encode the site URL and sitemap URL for API
          SITE_URL_ENCODED=$(printf %s "$SITE_URL" | jq -sRr @uri)
          SITEMAP_URL_ENCODED=$(printf %s "${{ steps.sitemap.outputs.sitemap-url }}" | jq -sRr @uri)
          
          # Submit sitemap using Search Console API (PUT request)
          RESPONSE=$(curl -s -w "\n%{http_code}" -X PUT \
            "https://www.googleapis.com/webmasters/v3/sites/${SITE_URL_ENCODED}/sitemaps/${SITEMAP_URL_ENCODED}" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $ACCESS_TOKEN")
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | sed '$d')
          
          if [ "$HTTP_CODE" = "204" ]; then
            echo "‚úÖ Successfully submitted to Google Search Console"
            echo "   HTTP Status: $HTTP_CODE (No Content - Success)"
          else
            echo "::warning::Google Search Console submission failed with HTTP $HTTP_CODE"
            if [ -n "$BODY" ]; then
              echo "   Response: $BODY"
            fi
          fi
