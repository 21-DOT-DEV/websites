name: Generate Markdown Documentation

on:
  workflow_call:
    inputs:
      ref:
        description: 'Git ref to checkout (branch, tag, or SHA)'
        required: true
        type: string
      targets:
        description: 'Space-separated list of targets to document (e.g., "P256K ZKP")'
        required: true
        type: string
    outputs:
      artifact-name:
        description: 'Name of the uploaded artifact containing markdown documentation'
        value: ${{ jobs.generate.outputs.artifact-name }}

jobs:
  generate:
    name: Generate markdown docs
    runs-on: macos-15
    permissions:
      contents: read
    outputs:
      artifact-name: md-21-dev
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref }}
      
      - name: Resolve dependencies
        run: swift package resolve
      
      - name: Build target arguments for documentation generation
        id: build-targets
        run: |
          targets="${{ inputs.targets }}"
          target_args=""
          
          for target in $targets; do
            target_args="$target_args --target $target"
          done
          
          echo "target-args=$target_args" >> $GITHUB_OUTPUT
          echo "üìö Target arguments: $target_args"
          echo "üìö Generating documentation for targets: ${{ inputs.targets }}"
      
      - name: Create Archives directory
        run: mkdir -p Archives
      
      - name: Generate DocC archive
        run: |
          echo "üî® Generating DocC archive..."
          
          if ! swift package \
            --allow-writing-to-directory ./Archives \
            generate-documentation \
            ${{ steps.build-targets.outputs.target-args }} \
            --output-path ./Archives/md-21-dev.doccarchive \
            --enable-experimental-combined-documentation; then
            echo "‚ùå DocC generation failed"
            exit 1
          fi
          
          # Verify archive was created
          if [ ! -d "./Archives/md-21-dev.doccarchive" ]; then
            echo "‚ùå Archive not found after generation"
            ls -la Archives/ || echo "Archives directory is empty"
            exit 1
          fi
          
          echo "‚úÖ DocC archive generated successfully"
          ls -lh Archives/
      
      - name: Export to markdown
        run: |
          echo "üìù Exporting DocC archive to markdown..."
          
          if ! swift run docc4llm export \
            Archives/md-21-dev.doccarchive \
            --format markdown \
            --output md-21-dev-concatenated.md; then
            echo "‚ùå Markdown export failed"
            exit 1
          fi
          
          # Verify export output was created
          if [ ! -f "md-21-dev-concatenated.md" ]; then
            echo "‚ùå Exported markdown file not found"
            ls -la
            exit 1
          fi
          
          echo "‚úÖ Markdown export completed"
          ls -lh md-21-dev-concatenated.md
      
      - name: Validate delimiter format
        run: |
          START_COUNT=$(grep -c "^=== START FILE:" md-21-dev-concatenated.md || true)
          END_COUNT=$(grep -c "^=== END FILE ===$" md-21-dev-concatenated.md || true)
          
          if [ "$START_COUNT" -eq 0 ] || [ "$END_COUNT" -eq 0 ]; then
            echo "‚ùå Format validation failed"
            echo "START markers: $START_COUNT"
            echo "END markers: $END_COUNT"
            echo "Expected: >0 for both"
            exit 1
          fi
          
          if [ "$START_COUNT" -ne "$END_COUNT" ]; then
            echo "‚ùå Delimiter mismatch"
            echo "START markers: $START_COUNT"
            echo "END markers: $END_COUNT"
            exit 1
          fi
          
          echo "‚úì Format validation passed (delimiters: $START_COUNT)"
      
      - name: Split markdown into individual files
        run: |
          mkdir -p Websites/md-21-dev
          
          awk '/=== START FILE: /{
            gsub(/ ===$/, "", $4);
            path=$4;
            sub(/^data\/documentation\//, "", path);
            sub(/\.[^.]+$/, ".md", path);
            
            # Filter logic - skip unwanted files
            filename = path; sub(/.*\//, "", filename);
            
            # Skip protocol implementations and standard operators
            if (filename ~ /-implementations\.md$|^(!=|==|~)\(|^hash\(into:|^hashvalue\.md$/) next;
            
            # Skip comparison and range operators
            if (filename ~ /^_\(|^_=\(|^\x27\.\.\.|^compare\(_:_:\)\.md$/) next;
            
            # Skip standard initializers
            if (filename ~ /^init\(\)\.md$|^init\(arrayliteral:|^init\(rawvalue:|^init\(from:/) next;
            
            # Skip collection/sequence methods
            if (filename ~ /^(allsatisfy|compactmap|contains\(|count\(where|drop|elementsequal|enumerated|filter\(|first\(where|flatmap|foreach|formatted|lazy|lexicographically|makeiterator|map\(|max\(|min\(|prefix|publisher|reduce|reversed|sequence-|shuffled|sorted|split|starts|suffix|underestimated|withcontiguous)/) next;
            
            # Skip numeric utility methods
            if (filename ~ /^(advanced|distance|stride|negate|signum|add|subtract|multiply|divide|remainder|quotient|leading|trailing|nonzero|bitwidth|byteswapped|magnitude\.md$|words\.md$|zero-|issigned|ismultiple)/) next;
            
            # Skip entire utility directories
            if (path ~ /^(p256k|zkp)\/(foundation|swift\/simd|swift\/string|simdwrapper|simdwordsinteger|int128\/|int256\/|uint128\/|uint256\/)/) next;
            
            # Keep crypto-specific files
            if (path ~ /sign|verify|signature|ecdsa|schnorr|recover|musig|keyagreement|sharedsecret|privatekey|publickey|xonlykey|nonce|sha256/) {
              outpath="Websites/md-21-dev/"path;
              system("mkdir -p \"$(dirname \""outpath"\")\"");
              next;
            }
            
            # Keep shallow files (main types)
            depth = gsub(/\//, "/", path);
            if (depth <= 2) {
              outpath="Websites/md-21-dev/"path;
              system("mkdir -p \"$(dirname \""outpath"\")\"");
            }
            next;
          }
          /=== END FILE ===/{
            close(outpath);
            outpath="";
            next
          }
          outpath{
            print > outpath
          }' md-21-dev-concatenated.md
          
          FILE_COUNT=$(find Websites/md-21-dev -type f -name "*.md" | wc -l)
          echo "‚úì File splitting complete (files: $FILE_COUNT)"
      
      - name: Monitor deployment size
        run: |
          FILE_COUNT=$(find Websites/md-21-dev -type f | wc -l)
          SIZE_MB=$(du -sm Websites/md-21-dev | cut -f1)
          
          echo "Files: $FILE_COUNT"
          echo "Size: ${SIZE_MB}MB"
          
          if [ "$FILE_COUNT" -gt 15000 ]; then
            echo "::warning::Approaching file limit: $FILE_COUNT files (limit: 20,000)"
          fi
          
          if [ "$SIZE_MB" -gt 20 ]; then
            echo "::warning::Approaching size limit: ${SIZE_MB}MB (limit: 25MB)"
          fi
      
      - name: Generate sitemap
        run: |
          output_dir="Websites/md-21-dev"
          sitemap_file="${output_dir}/sitemap.xml"
          
          echo "üó∫Ô∏è  Generating sitemap for md-21-dev..."
          
          # Read lastmod date from state file (will be updated by lefthook-plugin when package version changes)
          if [ -f "Resources/sitemap-state.json" ]; then
            lastmod=$(jq -r '.generated_date' Resources/sitemap-state.json)
            echo "üìÖ Using lastmod from state file: $lastmod"
          else
            # Fallback to current date if state file doesn't exist
            lastmod=$(date -u +"%Y-%m-%d")
            echo "‚ö†Ô∏è  State file not found, using current date: $lastmod"
          fi
          
          # Start sitemap XML
          cat > "$sitemap_file" << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
          
          EOF
          
          # Find all markdown files and generate URL entries
          find "${output_dir}" -name "*.md" -type f | sort | while read -r file; do
            # Convert file path to URL path
            url_path=$(echo "$file" | sed "s|^${output_dir}/||")
            
            # Build absolute URL (md.21.dev subdomain)
            url="https://md.21.dev/${url_path}"
            
            # Escape XML special characters in URL (using basic sed substitution)
            escaped_url=$(echo "$url" | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g; s/'"'"'/\&apos;/g; s/"/\&quot;/g')
            
            # Add URL entry to sitemap
            cat >> "$sitemap_file" << EOF
          <url>
            <loc>${escaped_url}</loc>
            <lastmod>${lastmod}</lastmod>
          </url>
          
          EOF
          done
          
          # Close sitemap XML
          echo "</urlset>" >> "$sitemap_file"
          
          # Count URLs and display summary
          url_count=$(grep -c "<loc>" "$sitemap_file" || echo "0")
          echo "‚úÖ Sitemap generated with ${url_count} URLs"
          echo "üìÑ Sitemap location: ${sitemap_file}"
          
          # Validate sitemap is not empty
          if [ "$url_count" -eq 0 ]; then
            echo "‚ùå Error: Sitemap contains no URLs"
            exit 1
          fi
      
      - name: Create root index
        run: |
          cd Websites/md-21-dev
          
          # Count total files
          TOTAL_COUNT=$(find . -type f -name "*.md" | wc -l | tr -d ' ')
          
          cat > index.md << 'EOF'
          # Swift secp256k1 Documentation
          
          LLM-optimized markdown documentation for the swift-secp256k1 library.
          
          **Total Files**: TOTAL_COUNT markdown files
          
          ## Modules
          
          - [P256K Module](./p256k.md) - secp256k1 Elliptic Curve cryptography
          - [ZKP Module](./zkp.md) - Zero-Knowledge Proof operations
          
          ## Organization
          
          Each API symbol has its own markdown file at `/{module}/{symbol-name}.md`
          
          Navigate via module overviews or browse directories directly.
          EOF
          
          # Replace placeholder with actual count
          sed -i '' "s/TOTAL_COUNT/$TOTAL_COUNT/g" index.md
          
          echo "‚úì Created index.md with $TOTAL_COUNT total files"
            
      - name: Create robots.txt for LLM-only access
        run: |
          cd Websites/md-21-dev
          
          cat > robots.txt << 'EOF'
          # LLM/API consumption only - no search engine indexing
          User-agent: *
          Disallow: /
          
          # Tell crawlers where to find sitemap (even though indexing is disallowed)
          Sitemap: https://md.21.dev/sitemap.xml
          
          # AI training allowed
          Content-Signal: search=no, ai-train=yes
          EOF
          
          echo "‚úì Created robots.txt for LLM-only access with sitemap reference"
      
      - name: Create markdown archive
        run: |
          echo "üì¶ Creating archive for md-21-dev..."
          
          # Create zip archive (avoids GitHub Actions path validation issues)
          # Zip FROM INSIDE the directory to avoid nesting
          cd Websites/md-21-dev
          zip -r ../md-21-dev.zip .
          
          # Remove original directory to save space
          cd ..
          rm -rf md-21-dev
          
          echo "‚úÖ Archive created: Websites/md-21-dev.zip"
          ls -lh md-21-dev.zip
      
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: md-21-dev
          path: Websites/md-21-dev.zip
          retention-days: 1
