name: Generate Markdown Documentation

on:
  workflow_call:
    inputs:
      project-name:
        description: 'Documentation project name (e.g., md-21-dev)'
        required: true
        type: string
      ref:
        description: 'Git ref to checkout (branch, tag, or SHA)'
        required: true
        type: string
      targets:
        description: 'Space-separated list of targets to document (e.g., "P256K ZKP")'
        required: true
        type: string
    outputs:
      artifact-name:
        description: 'Name of the uploaded artifact containing markdown documentation'
        value: ${{ jobs.generate.outputs.artifact-name }}

jobs:
  generate:
    name: Generate markdown docs
    runs-on: macos-15
    permissions:
      contents: read
    outputs:
      artifact-name: ${{ inputs.project-name }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref }}
      
      - name: Resolve dependencies
        run: swift package resolve
      
      - name: Extract swift-secp256k1 version
        id: extract-version
        run: |
          SECP256K1_VERSION=$(jq -r '.pins[] | select(.identity == "swift-secp256k1") | .state.version' Package.resolved)
          echo "version=$SECP256K1_VERSION" >> $GITHUB_OUTPUT
          echo "SECP256K1_VERSION=$SECP256K1_VERSION" >> $GITHUB_ENV
          echo "üì¶ swift-secp256k1 version: $SECP256K1_VERSION"
      
      - name: Verify state file version matches Package.resolved
        run: |
          STATE_FILE="Resources/sitemap-state.json"
          
          if [ ! -f "$STATE_FILE" ]; then
            echo "‚ùå Error: State file not found at $STATE_FILE"
            echo "Please run 'lefthook install' to set up automatic state file management"
            exit 1
          fi
          
          STATE_VERSION=$(jq -r '.package_version' "$STATE_FILE")
          RESOLVED_VERSION="${{ env.SECP256K1_VERSION }}"
          
          echo "üìÑ State file version: $STATE_VERSION"
          echo "üì¶ Package.resolved version: $RESOLVED_VERSION"
          
          if [ "$STATE_VERSION" != "$RESOLVED_VERSION" ]; then
            echo ""
            echo "‚ùå ERROR: Version mismatch detected!"
            echo ""
            echo "State file version:        $STATE_VERSION"
            echo "Package.resolved version:  $RESOLVED_VERSION"
            echo ""
            echo "The sitemap state file is out of sync with Package.resolved."
            echo "This means the package version changed but the state file was not updated."
            echo ""
            echo "To fix this:"
            echo "1. Ensure lefthook is installed: 'lefthook install'"
            echo "2. The lefthook post-checkout hook will automatically update the state file"
            echo "3. Commit the updated Resources/sitemap-state.json file"
            echo ""
            exit 1
          fi
          
          echo "‚úÖ Version match confirmed: $STATE_VERSION"
      
      - name: Build target arguments for documentation generation
        id: build-targets
        run: |
          targets="${{ inputs.targets }}"
          target_args=""
          
          for target in $targets; do
            target_args="$target_args --target $target"
          done
          
          echo "target-args=$target_args" >> $GITHUB_OUTPUT
          echo "üìö Target arguments: $target_args"
          echo "üìö Generating documentation for targets: ${{ inputs.targets }}"
      
      - name: Create Archives directory
        run: mkdir -p Archives
      
      - name: Generate DocC archive
        run: |
          echo "üî® Generating DocC archive..."
          swift package \
            --allow-writing-to-package-directory \
            --allow-writing-to-directory ./Archives \
            generate-documentation \
            ${{ steps.build-targets.outputs.target-args }} \
            --output-path ./Archives/${{ inputs.project-name }}.doccarchive \
            --enable-experimental-combined-documentation
          if [ $? -ne 0 ]; then
            echo "‚ùå DocC generation failed"
            exit 1
          fi
          
          # Verify archive was created
          if [ ! -d "./Archives/${{ inputs.project-name }}.doccarchive" ]; then
            echo "‚ùå Archive not found after generation"
            ls -la Archives/ || echo "Archives directory is empty"
            exit 1
          fi
          
          echo "‚úÖ DocC archive generated successfully"
          ls -lh Archives/
      
      - name: Export to markdown
        run: |
          echo "üìù Exporting DocC archive to markdown..."
          
          if ! swift run docc4llm export \
            Archives/${{ inputs.project-name }}.doccarchive \
            --format markdown \
            --output ${{ inputs.project-name }}-concatenated.md; then
            echo "‚ùå Markdown export failed"
            exit 1
          fi
          
          # Verify export output was created
          if [ ! -f "${{ inputs.project-name }}-concatenated.md" ]; then
            echo "‚ùå Exported markdown file not found"
            ls -la
            exit 1
          fi
          
          echo "‚úÖ Markdown export completed"
          ls -lh ${{ inputs.project-name }}-concatenated.md
      
      - name: Validate delimiter format
        run: |
          START_COUNT=$(grep -c "^=== START FILE:" ${{ inputs.project-name }}-concatenated.md || true)
          END_COUNT=$(grep -c "^=== END FILE ===$" ${{ inputs.project-name }}-concatenated.md || true)
          
          if [ "$START_COUNT" -eq 0 ] || [ "$END_COUNT" -eq 0 ]; then
            echo "‚ùå Format validation failed"
            echo "START markers: $START_COUNT"
            echo "END markers: $END_COUNT"
            echo "Expected: >0 for both"
            exit 1
          fi
          
          if [ "$START_COUNT" -ne "$END_COUNT" ]; then
            echo "‚ùå Delimiter mismatch"
            echo "START markers: $START_COUNT"
            echo "END markers: $END_COUNT"
            exit 1
          fi
          
          echo "‚úì Format validation passed (delimiters: $START_COUNT)"
      
      - name: Split markdown into individual files
        run: |
          mkdir -p Websites/${{ inputs.project-name }}
          
          awk '/=== START FILE: /{
            gsub(/ ===$/, "", $4);
            path=$4;
            sub(/^data\/documentation\//, "", path);
            sub(/\.[^.]+$/, ".md", path);
            
            # Filter logic - skip unwanted files
            filename = path; sub(/.*\//, "", filename);
            
            # Skip protocol implementations and standard operators
            if (filename ~ /-implementations\.md$|^(!=|==|~)\(|^hash\(into:|^hashvalue\.md$/) next;
            
            # Skip comparison and range operators
            if (filename ~ /^_\(|^_=\(|^\x27\.\.\.|^compare\(_:_:\)\.md$/) next;
            
            # Skip standard initializers
            if (filename ~ /^init\(\)\.md$|^init\(arrayliteral:|^init\(rawvalue:|^init\(from:/) next;
            
            # Skip collection/sequence methods
            if (filename ~ /^(allsatisfy|compactmap|contains\(|count\(where|drop|elementsequal|enumerated|filter\(|first\(where|flatmap|foreach|formatted|lazy|lexicographically|makeiterator|map\(|max\(|min\(|prefix|publisher|reduce|reversed|sequence-|shuffled|sorted|split|starts|suffix|underestimated|withcontiguous)/) next;
            
            # Skip numeric utility methods
            if (filename ~ /^(advanced|distance|stride|negate|signum|add|subtract|multiply|divide|remainder|quotient|leading|trailing|nonzero|bitwidth|byteswapped|magnitude\.md$|words\.md$|zero-|issigned|ismultiple)/) next;
            
            # Skip entire utility directories
            if (path ~ /^(p256k|zkp)\/(foundation|swift\/simd|swift\/string|simdwrapper|simdwordsinteger|int128\/|int256\/|uint128\/|uint256\/)/) next;
            
            # Keep crypto-specific files
            if (path ~ /sign|verify|signature|ecdsa|schnorr|recover|musig|keyagreement|sharedsecret|privatekey|publickey|xonlykey|nonce|sha256/) {
              outpath="Websites/${{ inputs.project-name }}/"path;
              system("mkdir -p \"$(dirname \""outpath"\")\"");
              next;
            }
            
            # Keep shallow files (main types)
            depth = gsub(/\//, "/", path);
            if (depth <= 2) {
              outpath="Websites/${{ inputs.project-name }}/"path;
              system("mkdir -p \"$(dirname \""outpath"\")\"");
            }
            next;
          }
          /=== END FILE ===/{
            close(outpath);
            outpath="";
            next
          }
          outpath{
            print > outpath
          }' ${{ inputs.project-name }}-concatenated.md
          
          FILE_COUNT=$(find Websites/${{ inputs.project-name }} -type f -name "*.md" | wc -l)
          echo "‚úì File splitting complete (files: $FILE_COUNT)"
      
      - name: Monitor deployment size
        run: |
          FILE_COUNT=$(find Websites/${{ inputs.project-name }} -type f | wc -l)
          SIZE_MB=$(du -sm Websites/${{ inputs.project-name }} | cut -f1)
          
          echo "Files: $FILE_COUNT"
          echo "Size: ${SIZE_MB}MB"
          
          if [ "$FILE_COUNT" -gt 15000 ]; then
            echo "::warning::Approaching file limit: $FILE_COUNT files (limit: 20,000)"
          fi
          
          if [ "$SIZE_MB" -gt 20 ]; then
            echo "::warning::Approaching size limit: ${SIZE_MB}MB (limit: 25MB)"
          fi
      
      - name: Generate sitemap
        run: |
          output_dir="Websites/${{ inputs.project-name }}"
          sitemap_file="${output_dir}/sitemap.xml"
          
          echo "üó∫Ô∏è  Generating sitemap for ${{ inputs.project-name }}..."
          
          # Read lastmod date from state file (will be updated by lefthook-plugin when package version changes)
          if [ -f "Resources/sitemap-state.json" ]; then
            lastmod=$(jq -r '.generated_date' Resources/sitemap-state.json)
            echo "üìÖ Using lastmod from state file: $lastmod"
          else
            # Fallback to current date if state file doesn't exist
            lastmod=$(date -u +"%Y-%m-%d")
            echo "‚ö†Ô∏è  State file not found, using current date: $lastmod"
          fi
          
          # Start sitemap XML
          cat > "$sitemap_file" << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
          
          EOF
          
          # Find all markdown files and generate URL entries
          find "${output_dir}" -name "*.md" -type f | sort | while read -r file; do
            # Convert file path to URL path
            url_path=$(echo "$file" | sed "s|^${output_dir}/||")
            
            # Build absolute URL (md.21.dev subdomain)
            url="https://md.21.dev/${url_path}"
            
            # Escape XML special characters in URL (using basic sed substitution)
            escaped_url=$(echo "$url" | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g; s/'"'"'/\&apos;/g; s/"/\&quot;/g')
            
            # Add URL entry to sitemap
            cat >> "$sitemap_file" << EOF
          <url>
            <loc>${escaped_url}</loc>
            <lastmod>${lastmod}</lastmod>
          </url>
          
          EOF
          done
          
          # Close sitemap XML
          echo "</urlset>" >> "$sitemap_file"
          
          # Count URLs and display summary
          url_count=$(grep -c "<loc>" "$sitemap_file" || echo "0")
          echo "‚úÖ Sitemap generated with ${url_count} URLs"
          echo "üìÑ Sitemap location: ${sitemap_file}"
          
          # Validate sitemap is not empty
          if [ "$url_count" -eq 0 ]; then
            echo "‚ùå Error: Sitemap contains no URLs"
            exit 1
          fi
      
      - name: Copy static resources
        run: |
          project="${{ inputs.project-name }}"
          output_dir="Websites/${project}"
          resources_dir="Resources/${project}"
          
          echo "üìã Copying static resources for ${project}..."
          
          # Copy all files from resources directory
          if [ -d "${resources_dir}" ]; then
            file_count=0
            for file in "${resources_dir}"/*; do
              if [ -f "$file" ]; then
                name="$(basename "$file")"
                if [ "$name" = "_headers" ]; then
                  cp "$file" "${output_dir}/_headers"
                  echo "‚úÖ Copied _headers"
                else
                  cp "$file" "${output_dir}/"
                  echo "‚úÖ Copied $name"
                fi
                ((file_count++))
              fi
            done
            
            if [ "$file_count" -eq 0 ]; then
              echo "‚ö†Ô∏è  No static resources found in ${resources_dir}"
            else
              echo "‚úì Copied ${file_count} static resource(s)"
            fi
          else
            echo "‚ö†Ô∏è  Resources directory not found: ${resources_dir}"
          fi

          if [ ! -f "${output_dir}/_headers" ]; then
            echo "‚ùå Error: _headers file not present in ${output_dir}"
            echo "Ensure Resources/${project}/_headers exists before deploying."
            exit 1
          fi
      
      - name: Create markdown archive
        run: |
          echo "üì¶ Creating archive for ${{ inputs.project-name }}..."
          
          # Create zip archive (avoids GitHub Actions path validation issues)
          # Zip FROM INSIDE the directory to avoid nesting
          cd Websites/${{ inputs.project-name }}
          zip -r ../${{ inputs.project-name }}.zip .
          
          # Remove original directory to save space
          cd ..
          rm -rf ${{ inputs.project-name }}
          
          echo "‚úÖ Archive created: Websites/${{ inputs.project-name }}.zip"
          ls -lh ${{ inputs.project-name }}.zip
      
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.project-name }}
          path: Websites/${{ inputs.project-name }}.zip
          retention-days: 1
