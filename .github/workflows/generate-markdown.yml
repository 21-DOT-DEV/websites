name: Generate Markdown Documentation

on:
  workflow_call:
    inputs:
      ref:
        description: 'Git ref to checkout (branch, tag, or SHA)'
        required: true
        type: string
      targets:
        description: 'Space-separated list of targets to document (e.g., "P256K ZKP")'
        required: true
        type: string
    outputs:
      artifact-name:
        description: 'Name of the uploaded artifact containing markdown documentation'
        value: ${{ jobs.generate.outputs.artifact-name }}

jobs:
  generate:
    name: Generate markdown docs
    runs-on: macos-15
    permissions:
      contents: read
    outputs:
      artifact-name: md-21-dev
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref }}
      
      - name: Resolve dependencies
        run: swift package resolve
      
      - name: Build target arguments for documentation generation
        id: build-targets
        run: |
          targets="${{ inputs.targets }}"
          target_args=""
          
          for target in $targets; do
            target_args="$target_args --target $target"
          done
          
          echo "target-args=$target_args" >> $GITHUB_OUTPUT
          echo "üìö Target arguments: $target_args"
          echo "üìö Generating documentation for targets: ${{ inputs.targets }}"
      
      - name: Create Archives directory
        run: mkdir -p Archives
      
      - name: Generate DocC archive
        run: |
          echo "üî® Generating DocC archive..."
          
          if ! swift package \
            --allow-writing-to-directory ./Archives \
            generate-documentation \
            ${{ steps.build-targets.outputs.target-args }} \
            --output-path ./Archives/md-21-dev.doccarchive \
            --enable-experimental-combined-documentation; then
            echo "‚ùå DocC generation failed"
            exit 1
          fi
          
          # Verify archive was created
          if [ ! -d "./Archives/md-21-dev.doccarchive" ]; then
            echo "‚ùå Archive not found after generation"
            ls -la Archives/ || echo "Archives directory is empty"
            exit 1
          fi
          
          echo "‚úÖ DocC archive generated successfully"
          ls -lh Archives/
      
      - name: Export to markdown
        run: |
          echo "üìù Exporting DocC archive to markdown..."
          
          if ! swift run docc4llm export \
            Archives/md-21-dev.doccarchive \
            --format markdown \
            --output md-21-dev-concatenated.md; then
            echo "‚ùå Markdown export failed"
            exit 1
          fi
          
          # Verify export output was created
          if [ ! -f "md-21-dev-concatenated.md" ]; then
            echo "‚ùå Exported markdown file not found"
            ls -la
            exit 1
          fi
          
          echo "‚úÖ Markdown export completed"
          ls -lh md-21-dev-concatenated.md
      
      - name: Validate delimiter format
        run: |
          START_COUNT=$(grep -c "^=== START FILE:" md-21-dev-concatenated.md || true)
          END_COUNT=$(grep -c "^=== END FILE ===$" md-21-dev-concatenated.md || true)
          
          if [ "$START_COUNT" -eq 0 ] || [ "$END_COUNT" -eq 0 ]; then
            echo "‚ùå Format validation failed"
            echo "START markers: $START_COUNT"
            echo "END markers: $END_COUNT"
            echo "Expected: >0 for both"
            exit 1
          fi
          
          if [ "$START_COUNT" -ne "$END_COUNT" ]; then
            echo "‚ùå Delimiter mismatch"
            echo "START markers: $START_COUNT"
            echo "END markers: $END_COUNT"
            exit 1
          fi
          
          echo "‚úì Format validation passed (delimiters: $START_COUNT)"
      
      - name: Split markdown into individual files
        run: |
          mkdir -p Websites/md-21-dev
          
          awk '/=== START FILE: /{
            gsub(/ ===$/, "", $4);
            path=$4;
            sub(/^data\/documentation\//, "", path);
            sub(/\.[^.]+$/, ".md", path);
            
            # Filter logic - skip unwanted files
            filename = path; sub(/.*\//, "", filename);
            
            # Skip protocol implementations and standard operators
            if (filename ~ /-implementations\.md$|^(!=|==|~)\(|^hash\(into:|^hashvalue\.md$/) next;
            
            # Skip comparison and range operators
            if (filename ~ /^_\(|^_=\(|^\x27\.\.\.|^compare\(_:_:\)\.md$/) next;
            
            # Skip standard initializers
            if (filename ~ /^init\(\)\.md$|^init\(arrayliteral:|^init\(rawvalue:|^init\(from:/) next;
            
            # Skip collection/sequence methods
            if (filename ~ /^(allsatisfy|compactmap|contains\(|count\(where|drop|elementsequal|enumerated|filter\(|first\(where|flatmap|foreach|formatted|lazy|lexicographically|makeiterator|map\(|max\(|min\(|prefix|publisher|reduce|reversed|sequence-|shuffled|sorted|split|starts|suffix|underestimated|withcontiguous)/) next;
            
            # Skip numeric utility methods
            if (filename ~ /^(advanced|distance|stride|negate|signum|add|subtract|multiply|divide|remainder|quotient|leading|trailing|nonzero|bitwidth|byteswapped|magnitude\.md$|words\.md$|zero-|issigned|ismultiple)/) next;
            
            # Skip entire utility directories
            if (path ~ /^(p256k|zkp)\/(foundation|swift\/simd|swift\/string|simdwrapper|simdwordsinteger|int128\/|int256\/|uint128\/|uint256\/)/) next;
            
            # Keep crypto-specific files
            if (path ~ /sign|verify|signature|ecdsa|schnorr|recover|musig|keyagreement|sharedsecret|privatekey|publickey|xonlykey|nonce|sha256/) {
              outpath="Websites/md-21-dev/"path;
              system("mkdir -p \"$(dirname \""outpath"\")\"");
              next;
            }
            
            # Keep shallow files (main types)
            depth = gsub(/\//, "/", path);
            if (depth <= 2) {
              outpath="Websites/md-21-dev/"path;
              system("mkdir -p \"$(dirname \""outpath"\")\"");
            }
            next;
          }
          /=== END FILE ===/{
            close(outpath);
            outpath="";
            next
          }
          outpath{
            print > outpath
          }' md-21-dev-concatenated.md
          
          FILE_COUNT=$(find Websites/md-21-dev -type f -name "*.md" | wc -l)
          echo "‚úì File splitting complete (files: $FILE_COUNT)"
      
      - name: Monitor deployment size
        run: |
          FILE_COUNT=$(find Websites/md-21-dev -type f | wc -l)
          SIZE_MB=$(du -sm Websites/md-21-dev | cut -f1)
          
          echo "Files: $FILE_COUNT"
          echo "Size: ${SIZE_MB}MB"
          
          if [ "$FILE_COUNT" -gt 15000 ]; then
            echo "::warning::Approaching file limit: $FILE_COUNT files (limit: 20,000)"
          fi
          
          if [ "$SIZE_MB" -gt 20 ]; then
            echo "::warning::Approaching size limit: ${SIZE_MB}MB (limit: 25MB)"
          fi
      
      - name: Create root index
        run: |
          cd Websites/md-21-dev
          
          # Count files by directory
          P256K_COUNT=$(find p256k -type f -name "*.md" 2>/dev/null | wc -l | tr -d ' ')
          ZKP_COUNT=$(find zkp -type f -name "*.md" 2>/dev/null | wc -l | tr -d ' ')
          TOTAL_COUNT=$(find . -type f -name "*.md" | wc -l | tr -d ' ')
          ZKP_UNIQUE=$(find zkp -type f -name "*.md" | while read f; do [ ! -f "${f/zkp/p256k}" ] && echo "$f"; done | wc -l | tr -d ' ')
          ZKP_SHARED=$((ZKP_COUNT - ZKP_UNIQUE))
          
          # Get directory size
          TOTAL_SIZE=$(du -sh . | cut -f1)
          
          # Generate full P256K tree structure
          P256K_TREE=$(if command -v tree &> /dev/null; then
            tree p256k/
          else
            find p256k -print | sed -e 's;[^/]*/;‚îÇ   ;g;s;‚îÇ   \([^‚îÇ]\);‚îî‚îÄ‚îÄ \1;'
          fi)
          
          # Sample some files from each module (first 5)
          P256K_SAMPLES=$(find p256k -type f -name "*.md" 2>/dev/null | sort | head -5 | sed 's|^\./||')
          ZKP_SAMPLES=$(find zkp -type f -name "*.md" 2>/dev/null | sort | head -5 | sed 's|^\./||')
          
          cat > index.md << EOF
          # Swift secp256k1 Documentation
          
          LLM-optimized markdown documentation for the swift-secp256k1 library.
          
          **Total Files**: $TOTAL_COUNT markdown files  
          **Total Size**: $TOTAL_SIZE
          
          ## Modules
          
          ### [P256K Module](./p256k.md)
          
          secp256k1 Elliptic Curve cryptography operations including key generation, ECDSA signing, ECDH key agreement, and public key recovery.
          
          - **Files**: $P256K_COUNT symbols
          - **Directory**: \`p256k/\`
          
          Sample symbols:
          EOF
          
          # Add P256K samples as links
          echo "$P256K_SAMPLES" | while read -r file; do
            if [ -n "$file" ]; then
              name=$(basename "$file" .md)
              echo "- [\`$name\`](./$file)" >> index.md
            fi
          done
          
          cat >> index.md << EOF
          
          ### [ZKP Module](./zkp.md)
          
          Zero-Knowledge Proof operations including Pedersen commitments, range proofs, and Schnorr signatures - builds on P256K primitives for confidential transactions.
          
          - **Files**: $ZKP_COUNT symbols
          - **Directory**: \`zkp/\`
          
          Sample symbols:
          EOF
          
          # Add ZKP samples as links
          echo "$ZKP_SAMPLES" | while read -r file; do
            if [ -n "$file" ]; then
              name=$(basename "$file" .md)
              echo "- [\`$name\`](./$file)" >> index.md
            fi
          done
          
          cat >> index.md << EOF
          
          ## Navigation Tree
          
          Complete module structure (ZKP follows identical organization):
          
          \`\`\`
          $P256K_TREE
          \`\`\`
          
          **Note**: The ZKP module mirrors this structure with $ZKP_UNIQUE additional unique methods for zero-knowledge proof operations.
          
          ## File Organization
          
          Each API symbol has its own markdown file:
          - **Pattern**: \`/{module}/{symbol-name}.md\`
          - **Format**: CommonMark markdown with consistent structure
          - **Content**: Swift signatures, parameter descriptions, return types, source links
          
          ## Programmatic Discovery
          
          For LLMs and automated tools:
          - [llms.txt at 21.dev](https://21.dev/llms.txt) - llms.txt standard index
          - \`AGENTS.md\` in swift-secp256k1 repository - Agent guidance and setup
          
          ## Module Overviews
          
          Start with module overview files for high-level understanding:
          - [P256K Module Overview](./p256k.md) - Elliptic curve primitives
          - [ZKP Module Overview](./zkp.md) - Zero-knowledge proof operations
          
          Then navigate to specific symbols via directory listings or search.
          EOF
          
          echo "‚úì Created index.md with $TOTAL_COUNT total symbols"
          echo "  - P256K: $P256K_COUNT symbols"
          echo "  - ZKP: $ZKP_COUNT symbols ($ZKP_SHARED shared, $ZKP_UNIQUE unique)"
      
      - name: Create markdown archive
        run: |
          echo "üì¶ Creating archive for md-21-dev..."
          
          # Create zip archive (avoids GitHub Actions path validation issues)
          # Zip FROM INSIDE the directory to avoid nesting
          cd Websites/md-21-dev
          zip -r ../md-21-dev.zip .
          
          # Remove original directory to save space
          cd ..
          rm -rf md-21-dev
          
          echo "‚úÖ Archive created: Websites/md-21-dev.zip"
          ls -lh md-21-dev.zip
      
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: md-21-dev
          path: Websites/md-21-dev.zip
          retention-days: 1
