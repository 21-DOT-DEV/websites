name: Generate DocC Documentation

on:
  workflow_call:
    inputs:
      project-name:
        description: 'Documentation project name (e.g., docs-21-dev)'
        required: true
        type: string
      targets:
        description: 'Space-separated list of targets to document (e.g., "P256K ZKP libsecp256k1 libsecp256k1_zkp")'
        required: true
        type: string
    outputs:
      artifact-name:
        description: 'Name of the uploaded documentation artifact'
        value: ${{ jobs.generate.outputs.artifact-name }}
      version:
        description: 'Extracted package version from Package.resolved'
        value: ${{ jobs.generate.outputs.version }}

jobs:
  generate:
    name: Generate Documentation
    runs-on: macos-15
    outputs:
      artifact-name: ${{ inputs.project-name }}
      version: ${{ steps.extract-version.outputs.version }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Resolve dependencies
        run: swift package resolve
      
      - name: Extract swift-secp256k1 version
        id: extract-version
        run: |
          SECP256K1_VERSION=$(jq -r '.pins[] | select(.identity == "swift-secp256k1") | .state.version' Package.resolved)
          echo "version=$SECP256K1_VERSION" >> $GITHUB_OUTPUT
          echo "SECP256K1_VERSION=$SECP256K1_VERSION" >> $GITHUB_ENV
          echo "üì¶ swift-secp256k1 version: $SECP256K1_VERSION"
      
      - name: Verify state file version matches Package.resolved
        run: |
          STATE_FILE="Resources/sitemap-state.json"
          
          if [ ! -f "$STATE_FILE" ]; then
            echo "‚ùå Error: State file not found at $STATE_FILE"
            echo "Please run 'lefthook install' to set up automatic state file management"
            exit 1
          fi
          
          STATE_VERSION=$(jq -r '.package_version' "$STATE_FILE")
          RESOLVED_VERSION="${{ env.SECP256K1_VERSION }}"
          
          echo "üìÑ State file version: $STATE_VERSION"
          echo "üì¶ Package.resolved version: $RESOLVED_VERSION"
          
          if [ "$STATE_VERSION" != "$RESOLVED_VERSION" ]; then
            echo ""
            echo "‚ùå ERROR: Version mismatch detected!"
            echo ""
            echo "State file version:        $STATE_VERSION"
            echo "Package.resolved version:  $RESOLVED_VERSION"
            echo ""
            echo "The sitemap state file is out of sync with Package.resolved."
            echo "This means the package version changed but the state file was not updated."
            echo ""
            echo "To fix this:"
            echo "1. Ensure lefthook is installed: 'lefthook install'"
            echo "2. The lefthook post-checkout hook will automatically update the state file"
            echo "3. Commit the updated Resources/sitemap-state.json file"
            echo ""
            exit 1
          fi
          
          echo "‚úÖ Version match confirmed: $STATE_VERSION"
      
      - name: Build target array for documentation generation
        id: build-targets
        run: |
          targets="${{ inputs.targets }}"
          target_args=""
          
          for target in $targets; do
            target_args="$target_args --target $target"
          done
          
          echo "target-args=$target_args" >> $GITHUB_OUTPUT
          echo "üìö Target arguments: $target_args"
          echo "üìö Generating documentation for targets: ${{ inputs.targets }}"
      
      - name: Generate documentation
        run: |
          set -e
          echo "üìö Generating documentation for targets: ${{ inputs.targets }}"
          echo "üì¶ Package version: ${{ env.SECP256K1_VERSION }}"
          echo "üìÇ Output path: ./Websites/${{ inputs.project-name }}"
          
          # Ensure output directory exists
          mkdir -p ./Websites/${{ inputs.project-name }}
          
          swift package \
            --allow-writing-to-directory ./Websites/${{ inputs.project-name }} \
            generate-documentation \
            ${{ steps.build-targets.outputs.target-args }} \
            --enable-experimental-combined-documentation \
            --transform-for-static-hosting \
            --source-service github \
            --source-service-base-url https://github.com/21-DOT-DEV/swift-secp256k1/blob/${{ env.SECP256K1_VERSION }} \
            --checkout-path .build/checkouts/swift-secp256k1 \
            --output-path ./Websites/${{ inputs.project-name }}
          
          echo "‚úÖ Documentation generation complete"
      
      - name: Verify documentation output
        run: |
          project="${{ inputs.project-name }}"
          echo "Checking documentation output..."
          ls -la Websites/${project}/
          
          # Verify index.html exists
          if [ ! -f "Websites/${project}/index.html" ]; then
            echo "Error: index.html not found in documentation output"
            exit 1
          fi
          
          # Verify documentation directory exists
          if [ ! -d "Websites/${project}/documentation" ]; then
            echo "Error: documentation directory not found"
            exit 1
          fi
          
          # Verify JavaScript directory exists (for search functionality)
          if [ ! -d "Websites/${project}/js" ]; then
            echo "Error: js directory not found (search functionality missing)"
            exit 1
          fi
          
          echo "‚úÖ Documentation output verified successfully"
          echo "üìä Documentation size: $(du -sh Websites/${project} | cut -f1)"
      
      - name: Generate sitemap
        run: |
          project="${{ inputs.project-name }}"
          output_dir="Websites/${project}"
          sitemap_file="${output_dir}/sitemap.xml"
          
          echo "üó∫Ô∏è  Generating sitemap for ${project}..."
          
          # Read lastmod date from state file (will be updated by lefthook-plugin when package version changes)
          if [ -f "Resources/sitemap-state.json" ]; then
            lastmod=$(jq -r '.generated_date' Resources/sitemap-state.json)
            echo "üìÖ Using lastmod from state file: $lastmod"
          else
            # Fallback to current date if state file doesn't exist
            lastmod=$(date -u +"%Y-%m-%d")
            echo "‚ö†Ô∏è  State file not found, using current date: $lastmod"
          fi
          
          # Start sitemap XML
          cat > "$sitemap_file" << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
          
          EOF
          
          # Find all HTML files under documentation/ directory and generate URL entries
          find "${output_dir}/documentation" -name "*.html" -type f | sort | while read -r file; do
            # Convert file path to URL path, stripping index.html for canonical URLs
            # (Cloudflare Pages redirects /path/index.html ‚Üí /path/)
            url_path=$(echo "$file" | sed -e "s|^${output_dir}/||" -e 's|/index\.html$|/|')
            
            # Build absolute URL (docs.21.dev subdomain)
            url="https://docs.21.dev/${url_path}"
            
            # Escape XML special characters in URL (using basic sed substitution)
            escaped_url=$(echo "$url" | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g; s/'"'"'/\&apos;/g; s/"/\&quot;/g')
            
            # Add URL entry to sitemap
            cat >> "$sitemap_file" << EOF
          <url>
            <loc>${escaped_url}</loc>
            <lastmod>${lastmod}</lastmod>
          </url>
          
          EOF
          done
          
          # Close sitemap XML
          echo "</urlset>" >> "$sitemap_file"
          
          # Count URLs and display summary
          url_count=$(grep -c "<loc>" "$sitemap_file" || echo "0")
          echo "‚úÖ Sitemap generated with ${url_count} URLs"
          echo "üìÑ Sitemap location: ${sitemap_file}"
          
          # Validate sitemap is not empty
          if [ "$url_count" -eq 0 ]; then
            echo "‚ùå Error: Sitemap contains no URLs"
            exit 1
          fi
      
      - name: Copy static resources
        run: |
          project="${{ inputs.project-name }}"
          output_dir="Websites/${project}"
          resources_dir="Resources/${project}"
          
          echo "üìã Copying static resources for ${project}..."
          
          # Select environment-specific headers based on branch
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "üîí Production build: using _headers.prod"
            header_source="${resources_dir}/_headers.prod"
          else
            echo "üîì Preview build: using _headers.dev"
            header_source="${resources_dir}/_headers.dev"
          fi
          
          if [ ! -f "$header_source" ]; then
            echo "‚ùå Error: Header file not found: $header_source"
            exit 1
          fi
          
          cp "$header_source" "${output_dir}/_headers"
          echo "‚úÖ Copied $header_source ‚Üí ${output_dir}/_headers"
          
          # Copy other static resources (excluding _headers variants)
          if [ -d "${resources_dir}" ]; then
            file_count=0
            for file in "${resources_dir}"/*; do
              if [ -f "$file" ]; then
                name="$(basename "$file")"
                # Skip _headers files (already handled above)
                if [[ "$name" == _headers* ]]; then
                  continue
                fi
                cp "$file" "${output_dir}/"
                echo "‚úÖ Copied $name"
                ((file_count++))
              fi
            done
            
            if [ "$file_count" -eq 0 ]; then
              echo "‚ÑπÔ∏è  No additional static resources found in ${resources_dir}"
            else
              echo "‚úì Copied ${file_count} additional static resource(s)"
            fi
          else
            echo "‚ö†Ô∏è  Resources directory not found: ${resources_dir}"
          fi

          if [ ! -f "${output_dir}/_headers" ]; then
            echo "‚ùå Error: _headers file not present in ${output_dir}"
            exit 1
          fi
      
      - name: Create documentation archive
        run: |
          project="${{ inputs.project-name }}"
          echo "üì¶ Creating archive for ${project}..."
          
          # Create zip archive (avoids GitHub Actions path validation issues)
          # Zip FROM INSIDE the directory to avoid nesting
          cd "Websites/${project}"
          zip -r "../${project}.zip" .
          
          # Remove original directory to save space
          cd ..
          rm -rf "${project}"
          
          echo "‚úÖ Archive created: Websites/${project}.zip"
          ls -lh "${project}.zip"
      
      - name: Upload documentation artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.project-name }}
          path: Websites/${{ inputs.project-name }}.zip
          retention-days: 1
